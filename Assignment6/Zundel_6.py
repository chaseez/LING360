# -*- coding: utf-8 -*-
"""Zundel_6.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1CoBXQdFY2JB6mco81gKk9twbYhXuRfsl
"""

import nltk
import re
import os

nltk.download('stopwords')

from nltk.corpus import stopwords


# Here's the URL to download the Mini-CORE files
# https://byu.instructure.com/courses/23276/files/7179975?module_item_id=1821566

def word_counts(lines, dictionary, stop_words):
  for line in lines:
    # Cleaning HTML Tags
    line = re.sub(r'<.+>', '', line)
    # Replacing any extra punctuation with a space
    line = re.sub(r'[\[\]\\."\',!?\(\)%\|\-:/]', ' ', line)
    # Replacing any numbers with a space
    line = re.sub(r'[0-9]+', ' ', line)

    # Removing excess whitespace, making the line lowercase, and generate a list of words
    words = line.strip().lower().split()

    for word in words:
      # Checking if the word is not a stop word
      if word not in stop_words:
          # Adding a new word to the dictionary
          if word not in dictionary:
            dictionary[word] = 0
          dictionary[word] += 1


def sort_counts(dictionary):
  # Getting a list of tuples like (word, count)
  word_count = list(dictionary.items())
  # Sorting word_count by the count from highest to lowest
  word_count.sort(key=lambda i:i[1], reverse=True)
  return word_count

def sorted_list_to_csv(sorted_list, register):
  with open(f'./csv_files/{register}_frequency_list.csv', 'w') as outfile:
    # Writing headers
    headers = ['word', 'count']
    outfile.write(','.join(headers))
    outfile.write('\n')

    # Writing each word with the associated count
    for word, count in sorted_list:
      outfile.write(f'{word},{count}\n')


if __name__ == '__main__':
    # Initializing variables
    registers = ['HI', 'ID', 'IN', 'IP', 'LY', 'NA', 'OP', 'SP']

    HI = {}
    ID = {}
    IN = {}
    IP = {}
    LY = {}
    NA = {}
    OP = {}
    SP = {}

    # Getting all the files in the current directory
    files = os.listdir('./Mini-CORE_new')

    # Filtering out all the files that don't have the .txt extention
    txt_files = [i for i in files if '.txt' in i]

    # Getting a list of the stopwords in English
    all_stop_words = stopwords.words('english')

    # Loop through all the .txt files in the current directory
    for curr_file in txt_files:
      with open(f'./Mini-CORE_new/{curr_file}', 'r', encoding='cp437') as in_file:
        # Getting the register genre (the letters at the indexes 2 and 3)
        register = curr_file[2:4]
        lines = list(in_file)

        # Update the word count for the corresponding dictionary for each file
        if register == 'HI':
          word_counts(lines, HI, all_stop_words)
        elif register == 'ID':
          word_counts(lines, ID, all_stop_words)
        elif register == 'IN':
          word_counts(lines, IN, all_stop_words)
        elif register == 'IP':
          word_counts(lines, IP, all_stop_words)
        elif register == 'LY':
          word_counts(lines, LY, all_stop_words)
        elif register == 'NA':
          word_counts(lines, NA, all_stop_words)
        elif register == 'OP':
          word_counts(lines, OP, all_stop_words)
        elif register == 'SP':
          word_counts(lines, SP, all_stop_words)

    # Looping through all the reigsters
    for register in registers:
        # Declared for scope sake
        sorted_list = []

        # Getting the sorted list based on the word count
        if register == 'HI':
          sorted_list = sort_counts(HI)
        elif register == 'ID':
          sorted_list = sort_counts(ID)
        elif register == 'IN':
          sorted_list = sort_counts(IN)
        elif register == 'IP':
          sorted_list = sort_counts(IP)
        elif register == 'LY':
          sorted_list = sort_counts(LY)
        elif register == 'NA':
          sorted_list = sort_counts(NA)
        elif register == 'OP':
          sorted_list = sort_counts(OP)
        elif register == 'SP':
          sorted_list = sort_counts(SP)

        # Write a csv based on the sorted list for the specific register genre
        sorted_list_to_csv(sorted_list, register)
